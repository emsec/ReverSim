import base64
import sys
import traceback
from typing import Any, Callable, Dict, Mapping
from flask import Blueprint, make_response, redirect, render_template, request, url_for
import jinja2

from werkzeug import Response
from markupsafe import escape

from app.model.Participant import Participant

import app.config as gameConfig
from app.router.jsonRPC import JSONRPC_VERSION, JsonRPC_Errcode, JsonRPC_Error, JsonRPC_INTERNAL_ERROR, JsonRPC_INVALID_PARAMS, JsonRPC_INVALID_REQUEST, JsonRPC_METHOD_NOT_FOUND, JsonRPC_PARSE_ERROR
from app.storage.ParticipantLogger import ParticipantLogger, PseudonymCollision
from app.storage.crashReport import isCrashReporterEnabled, writeCrashReport
from app.model.LogEvents import LogCreatedEvent, PlayerContext, ReconnectEvent, RedirectEvent
from app.storage.participantScreenshots import ScreenshotWriter
from app.utilsGame import EventType, now, sanitizeString

import app.storage.participantsDict as participantsDict

from app.storage.database import db

routerGame = Blueprint('gameRoutes', __name__)


# send back the index.html file
@routerGame.route('/') # type: ignore
def index() -> Response:
	"""Redirect the user to /index if enabled, or to /welcome otherwise."""
	return redirect(getDefaultUrl(request), 307) # type: ignore

@routerGame.route('/welcome') # type: ignore
def welcomeUser():
	group = request.args.get('group', default=participantsDict.getAutomaticGroup())
	lang = sanitizeString(request.args.get('lang', default=gameConfig.getDefaultLang()))

	group, _ = Participant.createGroup(group)
	gamerules = gameConfig.getGroup(group)['config']

	user: dict[str, str|int|dict[str, Any]] = {
		'lang': lang,
		'languages': gameConfig.get('languages'),
		'group': group, 
		'author': gameConfig.config('author', ''), # html head
		'footer': gameConfig.getFooter(),
		'gamerules': jinja2.utils.htmlsafe_json_dumps(gamerules),
		'game_hash': gameConfig.getGitHash()
	}
	return render_template('welcome.html', **user)


@routerGame.route('/game') # type: ignore
def redirectToGame():
	"""Let the user play the actual HRE game. 

	Sends back the game.html template. The GET parameters ui and lang need to be specified and ui must have been generated by pre_survey.
	"""
	ui = sanitizeString(request.args.get('ui'))
	lang = sanitizeString(request.args.get('lang', default=gameConfig.getDefaultLang()))
	
	# If the pseudonym is invalid, ask the user to generate a new one
	if not participantsDict.exists(ui):
		return 'Invalid or unknown pseudonym. Please generate a new one by going <a href="' + \
				getDefaultUrl(request) + '">back</a>.', 400

	participant = participantsDict.get(ui)
	assert participant.group is not None
	user: Dict[str, str|int] = {
		'username': ui, 
		'lang': lang, 
		'group': participant.group, 
		'author': gameConfig.config('author', ''),
		'gamerules': jinja2.utils.htmlsafe_json_dumps(participant.getGamerules()),
		'game_hash': gameConfig.getGitHash(),
		'crashReporterEnabled': isCrashReporterEnabled(participant.group),
		'crashReportLevel': gameConfig.getInt('crashReportLevel')
	}
	return render_template('game.html', **user)


@routerGame.route('/pre_survey') # type: ignore
def redirectToPreSurvey():
	"""Redirect the user to the pre-survey. 
	
	The link is determined by the variable urlPreSurvey. Generate a pseudonym and create a logfile structure beforehand.
	This should be the first endpoint a user reaches out to, as the pseudonym is needed by most other endpoints. 
	"""
	group = request.args.get('group', default=None)
	pseudonym = None

	# Don't sanitize None
	if group is None:
		group = participantsDict.getAutomaticGroup()
	
	group, isDebug = Participant.createGroup(group)

	# Create prerequisites for the Participant
	try:
		for _ in range(0, 5):
			tmpPseudonym = participantsDict.generatePseudonym(str(request.remote_addr))
			if not participantsDict.exists(tmpPseudonym):
				pseudonym = tmpPseudonym
				break

		# Check that a valid pseudonym was generated
		if pseudonym is None:
			print("Failed to generate a pseudonym", file=sys.stderr)
			return 'Could not generate a valid pseudonym, please inform the developers.', 500
		
		# Create entry in new database logger
		loggingEnabled = gameConfig.isLoggingEnabled(group)
		PlayerContext.createPlayer(pseudonym, loggingEnabled)

		try:
			# If logging is enabled, create a log file
			if loggingEnabled:
				ParticipantLogger.createLogfile(pseudonym)

				event = LogCreatedEvent(
					clientTime=None,
					serverTime=now(),
					pseudonym=pseudonym,
					version=gameConfig.LOGFILE_VERSION,
					gitHashS=gameConfig.getGitHash()
				)
				event.commit()

		except PseudonymCollision as e:
			print("Pseudonym collision: " + str(e))
			return "The generated pseudonym already existed, please restart the game.", 500

		# create and insert into the participantsDict
		participant = Participant(pseudonym, group, isDebug=isDebug)
		participantsDict.insertParticipant(participant)

		# presurvey link and params for the game link
		presurveyLink = participant.getLink('urlPreSurvey', request.args)
		skipPresurvey = isDebug

		# Redirect to preSurvey if not in debug mode and a redirect link exists.
		# Previous query params are dropped for the preSurvey but are kept when redirecting to the main game
		if isinstance(presurveyLink, str) and not skipPresurvey:
			redirectLink = presurveyLink
		else:
			redirectLink = url_for("gameRoutes.redirectToGame", **{**request.args, **{'ui': pseudonym}}) # type: ignore

		# Write the redirect to log (if logging is enabled)
		if loggingEnabled:
			msg1 = '§Destination: ' + redirectLink
			participant.logger.writeToLog(EventType.Redirect, msg1, now())

		participant.startedPresurvey = True

		event = RedirectEvent(
			clientTime=None,
			serverTime=now(),
			pseudonym=pseudonym,
			destination=redirectLink
		)
		event.commit()

		# Flask-SQLAlchemy does not commit at the end of a session...
		db.session.commit()

	# Something went seriously wrong
	except gameConfig.GroupNotFound as e:
		print(str(e))
		return "The group " + group + " is unknown", 400

	except Exception as e:
		print("Error: Could not create storage for the participant: \n" + str(e))
		return "Could not create storage for the participant", 500

	return redirect(redirectLink, code=307)


@routerGame.route('/post_survey') # type: ignore
def redirectToPostSurvey():
	"""Redirect the user to the post-survey, after they finished playing the game.

	The url for the post-survey can be changed with the variable urlPostSurvey.
	"""
	ui = sanitizeString(request.args['ui'])
	lang = sanitizeString(request.args.get('lang', default=gameConfig.getDefaultLang()))
	timeStamp = str(now()) # sanitizeString(request.args.get('timeStamp')) #DONE don't trust the client timestamp here

	if not participantsDict.exists(ui):
		return 'invalid ui', 400

	participant = participantsDict.get(ui)
	redirectLink = participant.getLink('urlPostSurvey', request.args, lang)

	# Sanity check, if there is a redirect link
	if redirectLink is None:
		print("Error: The player was redirected to the post_survey, but there is none! Group: " + str(participant.group) + ".")
		return "There is no post survey for this group (" + str(participant.group) + "). Also you should not be able to see this page...", 400

	# Write the redirect to the logs
	msg = '§Destination: ' + redirectLink
	participant.logger.writeToLog(EventType.Redirect, msg, timeStamp)

	# Increase the group counter
	participantsDict.increaseGroupCounter(participant, timeStamp)
	participant.startedPostsurvey = True

	event = RedirectEvent(
		clientTime=None,
		serverTime=now(),
		pseudonym=participant.pseudonym,
		destination=redirectLink
	)
	event.commit()

	# Flask-SQLAlchemy does not commit at the end of a session...
	db.session.commit()

	return redirect(redirectLink, code=307)


# save image
@routerGame.route('/canvasImage', methods=['POST']) # type: ignore
def saveCanvasImage():
	"""Receive a screenshot from the player canvas.
	
	The Request params must contain the pseudonym of the player. The request body shall contain the Base64 encoded PNG snapshot of the players canvas. 
	The pictures are stored under "statistics/<ui>/<phase>/<picNmbr>.png" for most phases and "statistics/<ui>/<phase>/<levelName>/<picNmbr>.png" for the quali and competition phase
	"""
	imgstring = escape(request.form['canvasImage'])
	imgstring = imgstring.replace('data:image/png;base64,', '')
	imgdata = base64.b64decode(imgstring)

	pseudonym = sanitizeString(request.form['pseudonym'])

	if not participantsDict.exists(pseudonym):
		return 'Invalid pseudonym', 400

	participant = participantsDict.get(pseudonym)
	phase = participant.getPhase()
	path = ScreenshotWriter.getPath(
		pseudonym=participant.pseudonym, 
		phaseName=phase.name, 
		levelName=phase.getLevel().getName() if phase.hasLevels() else None,
		phaseIdx=phase.index
	)

	# Write the image file and increment the picNmbr stored in the phase
	try:
		ScreenshotWriter.writeScreenshot(path, phase.picNmbr, imgdata)
		phase.picNmbr += 1

	except FileNotFoundError:
		print('Path not found:'  + str(path))
		return 'File or path not found'

	# Flask-SQLAlchemy does not commit at the end of a session...
	db.session.commit()
	return 'image received'


@routerGame.route('/action', methods=['POST']) # type: ignore
def action():
	try:
		try:
			pseudonym = sanitizeString(request.headers['ui'])
			participant = participantsDict.get(pseudonym)
			transmissionTime = int(request.headers['time'])
			serverTime = now()
		except KeyError:
			raise JsonRPC_Error(JsonRPC_Errcode.S_AUTH_ERROR, desc="Missing header ui/time", id=None)
		except ValueError:
			raise JsonRPC_Error(JsonRPC_Errcode.S_AUTH_ERROR, desc="Pseudonym is unknown", id=None)

		requestData: Any = request.json
		if requestData is None:
			raise JsonRPC_PARSE_ERROR(id=None)

		messageList: list[Dict[str, Any]] = requestData if isinstance(requestData, list) else [requestData]
		result: list[Dict[str, Any]] = []

		# Write a log entry when the time delta deviates
		participant.checkTimeDrift(clientTime=transmissionTime, serverTime=serverTime)

		# For each message
		for message in messageList:
			try:
				result.append(handlePacket(participant, message))

			except JsonRPC_Error as e:
				result.append(e.getResponse())
				print(participant.pseudonym + " " + str(e) + ": " + str(e.errorDescription))

		# Flask-SQLAlchemy does not commit at the end of a session...
		db.session.commit()

		# Return the result of the called method 
		response = make_response(jinja2.utils.htmlsafe_json_dumps(result[0] if len(result) == 1 else result), 200)
		response.headers.set('Content-Type', 'application/json')
		return response

	except JsonRPC_Error as e:
		response = make_response(e.getResponseText(), 406)
		response.headers.set('Content-Type', 'application/json')
		return response

	except Exception as e:
		print("Error in jsonRPC: " + str(e))
		traceback.print_exc()
		response = make_response(JsonRPC_INTERNAL_ERROR(id=None).getResponseText(), 500)
		response.headers.set('Content-Type', 'application/json')
		return response


def handlePacket(participant: Participant, message: Dict[str, Any]) -> Dict[str, Any]:
	"""Validate a packet and deliver it to the proper function"""
	METHODS: Dict[str, Callable[..., Any]] = {
		"status": participant.status,
		"confirm": participant.clickConfirm,
		"next": participant.next,
		"switch": participant.clickSwitch,
		"qualiState": participant.qualiStatus,
		"popup": participant.popUp,
		"drawSel": participant.selectDrawingTool,
		"draw": participant.useDrawingTool,
		"skip": participant.skipLevel,
		"simulate": participant.simulate,
		"slide": participant.slide,
		"changeLanguage": participant.changeLanguage,
		"chrono": participant.chronograph,
		"startGame": participant.startGame,
		"altTask": participant.altTask,
		"sessionState": participant.sessionState
	}

	# If any of the required keys is not found, a KeyError is raised which will be caught
	rawID = message.get("id", None)
	try:
		jsonrpcVersion = message["jsonrpc"]
		method = message["method"]
		params = message.get("params", None)
		sessionID = message.get("session", "")
		idx = None if rawID is None else int(rawID)
	except Exception:
		raise JsonRPC_INVALID_REQUEST(description="Invalid Request", id=rawID)
	
	# Check the time field (own extension to the JsonRPC spec)
	try:
		timeStamp = int(message["time"])
	except Exception:
		raise JsonRPC_Error(JsonRPC_Errcode.S_INVALID_TIME, desc="Missing required JsonRPC parameter time")

	# Check the version field
	if jsonrpcVersion != "2.0":
		raise JsonRPC_INVALID_REQUEST(description="Invalid value for field jsonRPC", id=rawID)
	
	oldIndex = participant.packetIndex

	if idx is not None:
		# Reset the packet index on a new connection
		if idx == 0:
			participant.packetIndex = 0
			participant.sessionID = sessionID

		# Check that the session id matches
		if participant.sessionID != sessionID:
			raise JsonRPC_Error(JsonRPC_Errcode.S_SESSION_MISMATCH, "This session is now invalid", id=idx)

		# Check that the packet index is correct
		if participant.packetIndex == idx:
			participant.packetIndex = idx + 1

		# Drop packets that are old / have been send twice
		elif participant.packetIndex > idx:
			raise JsonRPC_Error(JsonRPC_Errcode.S_DROPPED, f"Dropping old packet #{idx}.", id=idx)

		# The packet arrived out of order, reject the packet and hope that the client will resend it
		else:
			raise JsonRPC_Error(JsonRPC_Errcode.S_PACKET_ORDER, f"Expected packet #{participant.packetIndex}, got #{idx}.", id=idx)

		# Sanity check if a race condition occurred
		if idx != 0 and participant.packetIndex != oldIndex + 1:
			participant.packetIndex = oldIndex
			print(f"[ERROR] Packet #{participant.packetIndex} is smaller than old state #{oldIndex}!")
			raise ValueError(f"Packet #{participant.packetIndex} is smaller than old state #{oldIndex}!")

	try:
		# check if the method exists
		if method not in METHODS:
			raise JsonRPC_METHOD_NOT_FOUND(id=rawID)

		# params where given as a List
		if isinstance(params, list):
			result: Any = METHODS[method](timeStamp, *params)
			return {"jsonrpc": JSONRPC_VERSION, "result": result, "id": idx}
 
		# params where given as a Dict
		elif isinstance(params, Mapping):
			result: Any = METHODS[method](timeStamp, **params)
			return {"jsonrpc": JSONRPC_VERSION, "result": result, "id": idx}

		# params where omitted
		else:
			result: Any = METHODS[method](timeStamp) # type: ignore
			return {"jsonrpc": JSONRPC_VERSION, "result": result, "id": idx}

	except (KeyError, TypeError, ValueError):
		raise JsonRPC_INVALID_PARAMS(id=rawID)

	except JsonRPC_Error as e:
		e.requestID = idx
		raise e

	except Exception as e:
		raise JsonRPC_INTERNAL_ERROR(str(e), id=idx)


# client tests connection to server every second
@routerGame.route('/testConnection', methods=['POST']) # type: ignore
def testConnection():
	"""Called by the client every second to check if the server can be reached.
	
	The server keeps track of the players connection and creates a log entry if the player is reconnecting after an interruption.
	"""
	pseudonym = sanitizeString(request.form['pseudonym'])
	timeStamp = sanitizeString(request.form['timeStamp'])
	serverTime = now()

	try:
		participant = participantsDict.get(pseudonym)
		t = participant.lastConnection
		elapsed = (serverTime - t) / 1000 

		if elapsed >= gameConfig.BACK_ONLINE_THRESHOLD_S:
			participant.logger.writeToLog(EventType.BackOnline, '§Duration[s]: ' + str(elapsed), timeStamp)

			event = ReconnectEvent(
				clientTime=int(timeStamp), serverTime=serverTime,
				pseudonym=pseudonym,
				elapsed=elapsed
			)
			event.commit()

		participant.lastConnection = serverTime

		# Flask-SQLAlchemy does not commit at the end of a session...
		db.session.commit()

		return 'pong'
	except (KeyError, ValueError):
		pass

	return 'invalid pseudonym', 406


@routerGame.route('/crashReport', methods=['POST']) # type: ignore
def crashReport():
	"""Called by the server when an exception escapes to the browser or `console.error()` is called"""
	serverTime = now()
	
	writeCrashReport(
		pseudonym=request.form.get('ui', 'Unknown'),
		group=request.form.get('group', 'Unknown'),
		timestamp=serverTime,
		message=request.form.get('message', 'NoMessage'),
		stackTrace=request.form.get('trace', '')
	)

	return 'error information send', 200


def getDefaultUrl(request: Any):
	"""Get the /index url if group index is enabled, otherwise return /welcome"""
	target = "staticRoutes.groupIndex" if gameConfig.get('groupIndex')['enabled'] else "gameRoutes.welcomeUser"
	return url_for(target, **request.args)
